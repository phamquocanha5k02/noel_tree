<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Gifts & Lights</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; }

        #ui-layer {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; pointer-events: none; z-index: 100;
        }

        .badge {
            display: inline-block; background: rgba(0,0,0,0.7);
            border: 2px solid #FFD700; color: #FFD700;
            padding: 10px 25px; border-radius: 50px;
            font-size: 18px; font-weight: bold; margin-bottom: 10px;
            text-transform: uppercase; letter-spacing: 1px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            text-shadow: 0 0 10px #FFD700;
        }

        .guide { color: #ccc; font-size: 13px; margin-bottom: 20px; text-shadow: 0 2px 4px black;}

        button {
            pointer-events: auto; cursor: pointer;
            background: linear-gradient(to bottom, #D32F2F, #8B0000);
            color: #FFF; border: 2px solid #FFD700;
            padding: 15px 50px; border-radius: 30px;
            font-weight: 800; font-size: 16px;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        #camera-preview {
            position: absolute; top: 15px; right: 15px;
            width: 120px; height: 90px;
            border: 2px solid rgba(255,0,0,0.5);
            transform: scaleX(-1); opacity: 0.6; border-radius: 8px;
        }

        #error-log { display: none; position: absolute; top: 0; left: 0; color: red; background: rgba(0,0,0,0.8); z-index: 999; padding: 10px; }
    </style>
</head>
<body>
<div id="error-log"></div>
<div id="ui-layer">
    <div id="status" class="badge">üéÑ Giang Sinh An Lanh üéÑ</div>
    <div class="guide">
        üñê <b>X√≤e:</b> Bung Qu√† & ƒê√®n &nbsp;|&nbsp; üëå <b>Pinch:</b> Xem ·∫£nh &nbsp;|&nbsp; ‚úä <b>N·∫Øm:</b> Thu c√¢y
    </div>
    <button id="btnStart" onclick="startSystem()">B·∫ÆT ƒê·∫¶U</button>
</div>

<div id="canvas-container"></div>
<video class="input_video" style="display:none"></video>
<canvas id="camera-preview"></canvas>

<script>
    // ==========================================
    // 1. Vandiep
    // ==========================================
    const MUSIC_URL = "./audio.mp3";
    let bgMusic = new Audio(MUSIC_URL);
    bgMusic.loop = true; bgMusic.volume = 1.0;

    const loader = new THREE.TextureLoader();
    const photoFiles = ['./DAAN5788.JPG', './DAANE5788.JPG', './EMEME6404.JPG', './FOEU3477.JPG', './IMG_4326.JPG', './IMG_4334.JPG', './IMG_7240.JPG'];
    const photoTextures = [];
    photoFiles.forEach((f, i) => photoTextures[i] = loader.load(f));

    // --- Vandiep ---
    function createCustomTexture(type) {
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        const cx = 64, cy = 64;

        if (type === 'gold_glow') {
            // Vandiep
            const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
            grd.addColorStop(0, '#FFFFFF');
            grd.addColorStop(0.2, '#FFFFE0');
            grd.addColorStop(0.5, '#FFD700');
            grd.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);

        } else if (type === 'red_light') {
            // Vandiep
            const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
            grd.addColorStop(0, '#FFAAAA');
            grd.addColorStop(0.3, '#FF0000');
            grd.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grd; ctx.fillRect(0,0,128,128);

        } else if (type === 'gift_red') {
            // Vandiep
            ctx.fillStyle = '#D32F2F'; // Vandiep
            ctx.fillRect(20, 20, 88, 88);
            ctx.fillStyle = '#FFD700'; // Vandiep
            ctx.fillRect(54, 20, 20, 88); // Vandiep
            ctx.fillRect(20, 54, 88, 20); // Vandiep
            // Vandiep
            ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth=2; ctx.strokeRect(20,20,88,88);
        } else if (type === 'snow_flake') {
            // Tuy·∫øt m·ªÅm, tr·∫Øng, h∆°i m·ªù
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let i=0;i<6;i++){
                const ang = (Math.PI*2/6)*i;
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(ang)*14, cy + Math.sin(ang)*14);
            }
            ctx.stroke();
        }
        return new THREE.CanvasTexture(canvas);
    }

    const textures = {
        gold: createCustomTexture('gold_glow'),
        red: createCustomTexture('red_light'),
        gift: createCustomTexture('gift_red'),
        snow: createCustomTexture('snow_flake')
    };

    // ==========================================
    // 2. Vandiep
    // ==========================================
    const CONFIG = {
        goldCount: 2000,    // H·∫°t v√†ng
        redCount: 300,      // S·ªë l∆∞·ª£ng ƒë√®n ƒë·ªè
        giftCount: 150,     // S·ªë l∆∞·ª£ng h·ªôp qu√†
        snowCount: 600,     // S·ªë l∆∞·ª£ng h·∫°t tuy·∫øt
        explodeRadius: 65,
        photoOrbitRadius: 25,
        treeHeight: 70,
        treeBaseRadius: 35
    };

    let scene, camera, renderer;
    let groupGold, groupRed, groupGift, groupSnow; // Vandiep
    let fireworkGroup = null; // Ph√°o s√°ng v√πng bung qu√†
    let photoMeshes = [];
    let titleMesh, starMesh;

    let state = 'TREE';
    let prevState = 'TREE';
    let selectedIndex = 0;
    let handX = 0.5;

    // ==========================================
    // 3. Vandiep
    // ==========================================
    function init3D() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Vandiep
        groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.0);
        groupRed = createParticleSystem('red', CONFIG.redCount, 3.5); // Vandiep
        groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0); // Vandiep
        // Tuy·∫øt r∆°i nh·∫π ph√≠a tr∆∞·ªõc c√¢y
        groupSnow = createSnowSystem(CONFIG.snowCount, 1.6);

        createPhotos();
        createDecorations();
        animate();
    }

    function createParticleSystem(type, count, size) {
        const pPositions = [];
        const pExplodeTargets = [];
        const pTreeTargets = [];

        for(let i=0; i<count; i++) {
            // --- Vandiep ---
            const h = Math.random() * CONFIG.treeHeight;
            const y = h - CONFIG.treeHeight / 2;

            // Vandiep
            let radiusRatio = (type === 'gold') ? Math.sqrt(Math.random()) : 0.9 + Math.random()*0.1;

            const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
            const r = maxR * radiusRatio;
            const theta = Math.random() * Math.PI * 2;

            const tx = r * Math.cos(theta);
            const tz = r * Math.sin(theta);
            pTreeTargets.push(tx, y, tz);

            // --- Vandiep ---
            const u = Math.random();
            const v = Math.random();
            const phi = Math.acos(2 * v - 1);
            const lam = 2 * Math.PI * u;

            // Vandiep
            let radMult = (type === 'gift') ? 1.2 : 1.0;
            const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;

            const ex = rad * Math.sin(phi) * Math.cos(lam);
            const ey = rad * Math.sin(phi) * Math.sin(lam);
            const ez = rad * Math.cos(phi);
            pExplodeTargets.push(ex, ey, ez);

            // Vandiep
            pPositions.push(tx, y, tz);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
        geo.userData = { tree: pTreeTargets, explode: pExplodeTargets };

        const mat = new THREE.PointsMaterial({
            size: size,
            map: textures[type],
            transparent: true, opacity: 1.0,
            // Vandiep
            blending: (type === 'gift') ? THREE.NormalBlending : THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });

        const points = new THREE.Points(geo, mat);
        scene.add(points);
        return points;
    }

    // H·ªá h·∫°t tuy·∫øt r∆°i ri√™ng, kh√¥ng theo h√¨nh c√¢y
    function createSnowSystem(count, size) {
        const positions = [];
        const speeds = [];
        for (let i = 0; i < count; i++) {
            const x = (Math.random() - 0.5) * 160; // r·ªông h∆°n c√¢y
            const y = Math.random() * 120;        // cao ph√≠a tr√™n
            const z = -20 + Math.random() * 60;   // h∆°i ph√≠a tr∆∞·ªõc c√¢y
            positions.push(x, y, z);
            speeds.push(0.15 + Math.random() * 0.25);
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geo.userData = { speeds: speeds };

        const mat = new THREE.PointsMaterial({
            size: size,
            map: textures.snow,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);
        return points;
    }

    function createPhotos() {
        const geo = new THREE.PlaneGeometry(8, 8);
        const borderGeo = new THREE.PlaneGeometry(9, 9);
        const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });

        for(let i=0; i<photoFiles.length; i++) {
            const mat = new THREE.MeshBasicMaterial({
                map: photoTextures[i], side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geo, mat);
            const border = new THREE.Mesh(borderGeo, borderMat);
            border.position.z = -0.1;
            mesh.add(border);

            mesh.visible = false;
            mesh.scale.set(0,0,0);
            scene.add(mesh);
            photoMeshes.push(mesh);
        }
    }

    function createDecorations() {
        // Vandiep
        const canvas = document.createElement('canvas');
        canvas.width = 1024; canvas.height = 256;
        const ctx = canvas.getContext('2d');
        ctx.font = 'bold italic 90px "Times New Roman"';
        ctx.fillStyle = '#FFD700'; ctx.textAlign = 'center';
        ctx.shadowColor = "#FF0000"; ctx.shadowBlur = 40;
        ctx.fillText("MERRY CHRISTMAS", 512, 130);

        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending });
        titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
        titleMesh.position.set(0, 50, 0);
        scene.add(titleMesh);

        // Vandiep
        const starCanvas = document.createElement('canvas');
        starCanvas.width = 128; starCanvas.height = 128;
        const sCtx = starCanvas.getContext('2d');
        sCtx.fillStyle = "#FFFF00"; sCtx.shadowColor="#FFF"; sCtx.shadowBlur=20;
        sCtx.beginPath();
        const cx=64, cy=64, outer=50, inner=20;
        for(let i=0; i<5; i++){
            sCtx.lineTo(cx + Math.cos((18+i*72)/180*Math.PI)*outer, cy - Math.sin((18+i*72)/180*Math.PI)*outer);
            sCtx.lineTo(cx + Math.cos((54+i*72)/180*Math.PI)*inner, cy - Math.sin((54+i*72)/180*Math.PI)*inner);
        }
        sCtx.closePath(); sCtx.fill();
        const starTex = new THREE.CanvasTexture(starCanvas);
        const starMat = new THREE.MeshBasicMaterial({ map: starTex, transparent: true, blending: THREE.AdditiveBlending });
        starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), starMat);
        starMesh.position.set(0, CONFIG.treeHeight/2 + 2, 0);
        scene.add(starMesh);
    }

    // T·∫°o m·ªôt ƒë·ª£t ph√°o s√°ng b√πng l√™n quanh khu bung qu√†
    function spawnFireworks() {
        const count = 450;
        const positions = [];
        const velocities = [];
        const life = [];

        for (let i = 0; i < count; i++) {
            // b·∫Øt ƒë·∫ßu g·∫ßn t√¢m c√¢y, cao h∆°n m·ªôt ch√∫t
            const startY = 5 + Math.random() * 10;
            positions.push(
                (Math.random() - 0.5) * 6,
                startY,
                (Math.random() - 0.5) * 6
            );

            // v·∫≠n t·ªëc b·∫Øn ra m·ªçi h∆∞·ªõng
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const speed = 0.8 + Math.random() * 1.2;
            const vx = Math.sin(phi) * Math.cos(theta) * speed;
            const vy = Math.cos(phi) * speed * 1.3;
            const vz = Math.sin(phi) * Math.sin(theta) * speed;
            velocities.push(vx, vy, vz);

            life.push(1.0);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geo.userData = {
            life: life,
            velocities: velocities
        };

        const mat = new THREE.PointsMaterial({
            size: 2.4,
            map: textures.gold,
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true,
            color: new THREE.Color(1.0, 0.8, 0.3)
        });

        // N·∫øu ƒëang c√≥ ph√°o c≈© th√¨ remove ƒë·ªÉ kh√¥ng qu√° n·∫∑ng
        if (fireworkGroup) {
            scene.remove(fireworkGroup);
            fireworkGroup.geometry.dispose();
            fireworkGroup.material.dispose();
        }

        fireworkGroup = new THREE.Points(geo, mat);
        scene.add(fireworkGroup);
    }

    function updateParticleGroup(group, targetState, speed, handRotY, time, isBlinking) {
        const positions = group.geometry.attributes.position.array;
        const targetKey = (targetState === 'TREE') ? 'tree' : 'explode';
        const targets = group.geometry.userData[(targetState === 'PHOTO') ? 'explode' : targetKey];

        for(let i=0; i<positions.length; i++) {
            positions[i] += (targets[i] - positions[i]) * speed;
        }
        group.geometry.attributes.position.needsUpdate = true;

        // Vandiep
        if (targetState === 'TREE') {
            group.rotation.y += 0.003;
            // Vandiep
            if(isBlinking) {
                // ƒê√®n ƒë·ªè nh√°y khi ·ªü tr·∫°ng th√°i c√¢y
                const scale = 1 + Math.sin(time * 5) * 0.2;
                group.scale.set(scale, scale, scale);
            } else {
                group.scale.set(1,1,1);
            }
        } else if (targetState === 'EXPLODE') {
            // Trong EXPLODE, quay m·∫°nh h∆°n theo tay
            group.scale.set(1,1,1);
            group.rotation.y += (handRotY - group.rotation.y) * 0.08;
        } else {
            // PHOTO
            group.scale.set(1,1,1);
            group.rotation.y += (handRotY - group.rotation.y) * 0.05;
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const speed = 0.06;
        const handRotY = (handX - 0.5) * 2.5;

        // N·∫øu m·ªõi chuy·ªÉn sang EXPLODE th√¨ t·∫°o ph√°o s√°ng
        if (prevState !== 'EXPLODE' && state === 'EXPLODE') {
            spawnFireworks();
        }
        prevState = state;

        // Vandiep
        updateParticleGroup(groupGold, state, speed, handRotY, time, false);
        updateParticleGroup(groupRed, state, speed, handRotY, time, true); // Vandiep
        updateParticleGroup(groupGift, state, speed, handRotY, time, false);

        // C·∫≠p nh·∫≠t tuy·∫øt r∆°i (lu√¥n r∆°i, kh√¥ng ph·ª• thu·ªôc state)
        if (groupSnow) {
            const posAttr = groupSnow.geometry.getAttribute('position');
            const positions = posAttr.array;
            const speeds = groupSnow.geometry.userData.speeds;
            for (let i = 0; i < speeds.length; i++) {
                const idx = i * 3 + 1; // y
                positions[idx] -= speeds[i];
                // n·∫øu tuy·∫øt r∆°i xu·ªëng th·∫•p th√¨ spawn l·∫°i ph√≠a tr√™n
                if (positions[idx] < -40) {
                    positions[idx] = 80 + Math.random()*40;
                }
                // l·∫Øc nh·∫π theo gi√≥
                const xIdx = i * 3;
                positions[xIdx] += Math.sin(time*0.5 + i)*0.02;
            }
            posAttr.needsUpdate = true;
        }

        // C·∫≠p nh·∫≠t ph√°o s√°ng khi bung qu√†
        if (fireworkGroup) {
            const posAttr = fireworkGroup.geometry.getAttribute('position');
            const positions = posAttr.array;
            const life = fireworkGroup.geometry.userData.life;
            const vel = fireworkGroup.geometry.userData.velocities;

            for (let i = 0; i < life.length; i++) {
                const base = i * 3;
                // update v·ªã tr√≠
                positions[base]     += vel[base] * 0.4;
                positions[base + 1] += vel[base + 1] * 0.4;
                positions[base + 2] += vel[base + 2] * 0.4;

                // gi·∫£m t·ªëc & r∆°i xu·ªëng nh·∫π
                vel[base] *= 0.98;
                vel[base + 1] = vel[base + 1] * 0.98 - 0.01;
                vel[base + 2] *= 0.98;

                life[i] -= 0.01;
            }
            // gi·∫£m opacity d·∫ßn
            fireworkGroup.material.opacity = Math.max(0, fireworkGroup.material.opacity - 0.01);

            posAttr.needsUpdate = true;

            // n·∫øu ch·∫øt h·∫øt th√¨ remove
            if (fireworkGroup.material.opacity <= 0.02) {
                scene.remove(fireworkGroup);
                fireworkGroup.geometry.dispose();
                fireworkGroup.material.dispose();
                fireworkGroup = null;
            }
        }

        // Vandiep
        photoMeshes.forEach((mesh, i) => {
            if(!mesh.material.map && photoTextures[i]) {
                mesh.material.map = photoTextures[i]; mesh.material.needsUpdate = true;
            }
        });

        if (state === 'TREE') {
            titleMesh.visible = true; starMesh.visible = true;
            titleMesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
            starMesh.rotation.z -= 0.02;
            photoMeshes.forEach(m => { m.scale.lerp(new THREE.Vector3(0,0,0), 0.1); m.visible = false; });

        } else if (state === 'EXPLODE') {
            titleMesh.visible = false; starMesh.visible = false;

            const baseAngle = groupGold.rotation.y;
            const angleStep = (Math.PI * 2) / photoFiles.length;
            let bestIdx = 0; let maxZ = -999;

            photoMeshes.forEach((mesh, i) => {
                mesh.visible = true;
                const angle = baseAngle + i * angleStep;
                const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
                const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
                const y = Math.sin(time + i) * 3;

                mesh.position.lerp(new THREE.Vector3(x, y, z), 0.1);
                mesh.lookAt(camera.position);

                if (z > maxZ) { maxZ = z; bestIdx = i; }

                if (z > 5) {
                    const distScale = 1.0 + (z / CONFIG.photoOrbitRadius) * 0.8;
                    mesh.scale.lerp(new THREE.Vector3(distScale, distScale, distScale), 0.1);
                } else {
                    mesh.scale.lerp(new THREE.Vector3(0.6, 0.6, 0.6), 0.1);
                }
            });
            selectedIndex = bestIdx;

        } else if (state === 'PHOTO') {
            photoMeshes.forEach((mesh, i) => {
                if (i === selectedIndex) {
                    mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
                    mesh.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1);
                    mesh.lookAt(camera.position);
                    mesh.rotation.z = 0;
                } else {
                    mesh.scale.lerp(new THREE.Vector3(0,0,0), 0.1);
                }
            });
        }

        renderer.render(scene, camera);
    }

    // ==========================================
    // 4. Vandiep
    // ==========================================
    function startSystem() {
        document.getElementById('btnStart').style.display = 'none';
        bgMusic.play().catch(e => console.log(e));
        init3D();

        const video = document.getElementsByClassName('input_video')[0];
        const canvas = document.getElementById('camera-preview');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');

        let frameCnt = 0;
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        hands.onResults(results => {
            ctx.clearRect(0,0,100,75); ctx.drawImage(results.image, 0, 0, 100, 75);

            if(results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                handX = lm[9].x;

                const tips = [8,12,16,20];
                const wrist = lm[0];
                let openDist = 0;
                tips.forEach(i => openDist += Math.hypot(lm[i].x-wrist.x, lm[i].y-wrist.y));
                const avgDist = openDist / 4;
                const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);

                if (avgDist < 0.25) {
                    state = 'TREE';
                    statusDiv.innerText = "‚úä Thu C√¢y Th√¥ng"; statusDiv.style.color = "#FFD700";
                } else if (pinchDist < 0.05) {
                    state = 'PHOTO';
                    statusDiv.innerText = "üëå Xem ·∫¢nh"; statusDiv.style.color = "#00FFFF";
                } else {
                    state = 'EXPLODE';
                    statusDiv.innerText = "üñê Bung Qu√† & ·∫¢nh"; statusDiv.style.color = "#FFA500";
                }
            } else {
                state = 'TREE';
                statusDiv.innerText = "üéÑ Giang Sinh An Lanh üéÑ"; statusDiv.style.color = "#FFF";
            }
        });

        const cameraUtils = new Camera(video, {
            onFrame: async () => {
                frameCnt++; if(frameCnt%3 !== 0) return;
                await hands.send({image: video});
            }, width: 320, height: 240
        });
        cameraUtils.start();
    }

    window.addEventListener('resize', () => {
        if(camera) { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
    });
    function logError(e) { document.getElementById('error-log').style.display='block'; document.getElementById('error-log').innerText+=e+"\n"; }
</script>
</body>
</html>


